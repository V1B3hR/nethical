"""
Anomaly Detection and Alert System

Provides intelligent anomaly detection across all probes and manages
alerting and escalation policies.
"""

from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from typing import Any, Callable, Dict, List, Optional, Set
import statistics

from .base_probe import ProbeResult, ProbeStatus


class AlertSeverity(Enum):
    """Alert severity levels"""

    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"


@dataclass
class Alert:
    """Alert generated by anomaly detection"""

    alert_id: str
    severity: AlertSeverity
    probe_name: str
    message: str
    timestamp: datetime
    metrics: Dict[str, Any] = field(default_factory=dict)
    violations: List[str] = field(default_factory=list)
    acknowledged: bool = False
    resolved: bool = False
    escalated: bool = False

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            "alert_id": self.alert_id,
            "severity": self.severity.value,
            "probe_name": self.probe_name,
            "message": self.message,
            "timestamp": self.timestamp.isoformat(),
            "metrics": self.metrics,
            "violations": self.violations,
            "acknowledged": self.acknowledged,
            "resolved": self.resolved,
            "escalated": self.escalated,
        }


class AnomalyDetector:
    """
    Anomaly Detection System

    Analyzes probe results to detect anomalies, patterns, and trends
    that may indicate system issues.

    Features:
    - Statistical anomaly detection
    - Trend analysis
    - Pattern recognition
    - Correlation analysis
    """

    def __init__(
        self,
        sensitivity: float = 2.0,
        lookback_window: int = 100,
    ):
        """
        Initialize anomaly detector.

        Args:
            sensitivity: Standard deviations for anomaly threshold
            lookback_window: Number of historical samples to analyze
        """
        self.sensitivity = sensitivity
        self.lookback_window = lookback_window
        self._metric_history: Dict[str, List[float]] = {}

    def analyze(self, result: ProbeResult) -> Optional[Dict[str, Any]]:
        """
        Analyze probe result for anomalies.

        Args:
            result: Probe result to analyze

        Returns:
            Anomaly details if detected, None otherwise
        """
        anomalies = {}

        # Check for status anomalies
        if result.status == ProbeStatus.CRITICAL:
            anomalies["status"] = {
                "type": "critical_status",
                "severity": "high",
                "message": f"Probe {result.probe_name} in critical state",
            }

        # Check metric anomalies
        for metric_name, metric_value in result.metrics.items():
            if not isinstance(metric_value, (int, float)):
                continue

            key = f"{result.probe_name}.{metric_name}"

            # Add to history
            if key not in self._metric_history:
                self._metric_history[key] = []

            self._metric_history[key].append(metric_value)

            # Keep only lookback window
            if len(self._metric_history[key]) > self.lookback_window:
                self._metric_history[key].pop(0)

            # Check for anomaly
            if len(self._metric_history[key]) >= 10:  # Need minimum samples
                anomaly = self._detect_statistical_anomaly(
                    key,
                    metric_value,
                    self._metric_history[key][:-1],  # Exclude current value
                )
                if anomaly:
                    anomalies[metric_name] = anomaly

        return anomalies if anomalies else None

    def _detect_statistical_anomaly(
        self,
        metric_key: str,
        current_value: float,
        history: List[float],
    ) -> Optional[Dict[str, Any]]:
        """
        Detect statistical anomaly using z-score.

        Args:
            metric_key: Metric identifier
            current_value: Current metric value
            history: Historical values

        Returns:
            Anomaly details if detected
        """
        if len(history) < 2:
            return None

        try:
            mean = statistics.mean(history)
            stdev = statistics.stdev(history)

            if stdev == 0:
                return None

            z_score = abs((current_value - mean) / stdev)

            if z_score > self.sensitivity:
                return {
                    "type": "statistical_anomaly",
                    "severity": (
                        "high" if z_score > self.sensitivity * 1.5 else "medium"
                    ),
                    "z_score": z_score,
                    "current_value": current_value,
                    "mean": mean,
                    "stdev": stdev,
                    "message": f"Metric {metric_key} deviates {z_score:.2f} stdevs from mean",
                }

        except Exception:
            pass

        return None

    def detect_trend(
        self,
        probe_name: str,
        metric_name: str,
        min_samples: int = 5,
    ) -> Optional[str]:
        """
        Detect trend in metric values.

        Args:
            probe_name: Probe name
            metric_name: Metric name
            min_samples: Minimum samples needed

        Returns:
            Trend description if detected
        """
        key = f"{probe_name}.{metric_name}"

        if key not in self._metric_history:
            return None

        history = self._metric_history[key]

        if len(history) < min_samples:
            return None

        # Simple trend detection: check if consistently increasing or decreasing
        recent = history[-min_samples:]

        increasing = all(recent[i] <= recent[i + 1] for i in range(len(recent) - 1))
        decreasing = all(recent[i] >= recent[i + 1] for i in range(len(recent) - 1))

        if increasing:
            change = (
                ((recent[-1] - recent[0]) / recent[0] * 100) if recent[0] != 0 else 0
            )
            return f"Increasing trend: {change:.1f}% change over {min_samples} samples"
        elif decreasing:
            change = (
                ((recent[0] - recent[-1]) / recent[0] * 100) if recent[0] != 0 else 0
            )
            return f"Decreasing trend: {change:.1f}% change over {min_samples} samples"

        return None


class AlertSystem:
    """
    Alert Management and Escalation System

    Manages alerts, deduplication, and escalation policies.

    Features:
    - Alert deduplication
    - Escalation policies
    - Alert routing
    - Alert history
    """

    def __init__(
        self,
        escalation_threshold_seconds: int = 3600,
        max_alerts: int = 10000,
    ):
        """
        Initialize alert system.

        Args:
            escalation_threshold_seconds: Time before escalating unacknowledged alerts
            max_alerts: Maximum alerts to keep in history
        """
        self.escalation_threshold_seconds = escalation_threshold_seconds
        self.max_alerts = max_alerts
        self._alerts: List[Alert] = []
        self._active_alerts: Dict[str, Alert] = {}
        self._alert_handlers: Dict[AlertSeverity, List[Callable]] = {
            severity: [] for severity in AlertSeverity
        }
        self._next_alert_id = 1

    def create_alert(
        self,
        severity: AlertSeverity,
        probe_name: str,
        message: str,
        metrics: Optional[Dict[str, Any]] = None,
        violations: Optional[List[str]] = None,
    ) -> Alert:
        """
        Create a new alert.

        Args:
            severity: Alert severity
            probe_name: Name of probe triggering alert
            message: Alert message
            metrics: Additional metrics
            violations: List of violations

        Returns:
            Created alert
        """
        # Check for duplicate active alert
        alert_key = f"{probe_name}:{message}"
        if alert_key in self._active_alerts:
            # Return existing alert
            return self._active_alerts[alert_key]

        # Create new alert
        alert = Alert(
            alert_id=f"ALT-{self._next_alert_id:06d}",
            severity=severity,
            probe_name=probe_name,
            message=message,
            timestamp=datetime.utcnow(),
            metrics=metrics or {},
            violations=violations or [],
        )

        self._next_alert_id += 1
        self._alerts.append(alert)
        self._active_alerts[alert_key] = alert

        # Trim history
        if len(self._alerts) > self.max_alerts:
            old_alert = self._alerts.pop(0)
            alert_key = f"{old_alert.probe_name}:{old_alert.message}"
            if (
                alert_key in self._active_alerts
                and self._active_alerts[alert_key].resolved
            ):
                del self._active_alerts[alert_key]

        # Trigger handlers
        self._trigger_handlers(alert)

        return alert

    def acknowledge_alert(self, alert_id: str) -> bool:
        """Acknowledge an alert"""
        for alert in self._alerts:
            if alert.alert_id == alert_id:
                alert.acknowledged = True
                return True
        return False

    def resolve_alert(self, alert_id: str) -> bool:
        """Resolve an alert"""
        for alert in self._alerts:
            if alert.alert_id == alert_id:
                alert.resolved = True
                alert_key = f"{alert.probe_name}:{alert.message}"
                if alert_key in self._active_alerts:
                    del self._active_alerts[alert_key]
                return True
        return False

    def get_active_alerts(
        self,
        severity: Optional[AlertSeverity] = None,
    ) -> List[Alert]:
        """
        Get active alerts.

        Args:
            severity: Filter by severity

        Returns:
            List of active alerts
        """
        alerts = list(self._active_alerts.values())
        if severity:
            alerts = [a for a in alerts if a.severity == severity]
        return sorted(alerts, key=lambda a: a.timestamp, reverse=True)

    def check_escalation(self) -> List[Alert]:
        """
        Check for alerts that need escalation.

        Returns:
            List of alerts to escalate
        """
        now = datetime.utcnow()
        escalation_threshold = timedelta(seconds=self.escalation_threshold_seconds)
        to_escalate = []

        for alert in self._active_alerts.values():
            if not alert.acknowledged and not alert.escalated:
                age = now - alert.timestamp
                if age > escalation_threshold:
                    alert.escalated = True
                    to_escalate.append(alert)

        return to_escalate

    def register_handler(
        self,
        severity: AlertSeverity,
        handler: Callable[[Alert], None],
    ):
        """
        Register an alert handler.

        Args:
            severity: Severity level to handle
            handler: Handler function
        """
        self._alert_handlers[severity].append(handler)

    def _trigger_handlers(self, alert: Alert):
        """Trigger registered handlers for alert"""
        for handler in self._alert_handlers[alert.severity]:
            try:
                handler(alert)
            except Exception:
                pass  # Don't let handler errors block alert creation

    def get_metrics(self) -> Dict[str, Any]:
        """Get alert system metrics"""
        active = self.get_active_alerts()
        critical = [a for a in active if a.severity == AlertSeverity.CRITICAL]
        warning = [a for a in active if a.severity == AlertSeverity.WARNING]
        unacknowledged = [a for a in active if not a.acknowledged]

        return {
            "total_alerts": len(self._alerts),
            "active_alerts": len(active),
            "critical_alerts": len(critical),
            "warning_alerts": len(warning),
            "unacknowledged_alerts": len(unacknowledged),
            "escalated_alerts": sum(1 for a in active if a.escalated),
        }
