# Phase 8: Negative Properties Specification

## Overview

This document formally specifies **negative properties** — behaviors and state transitions that the Nethical system **must NOT** exhibit. These properties complement positive invariants (P-DET, P-TERM, P-ACYCLIC, P-AUD) by explicitly defining forbidden behaviors that would compromise security, integrity, or governance guarantees.

## Notation and Conventions

- **State Variables**: Uppercase (e.g., `AuditLog`, `PolicyStore`, `TenantData`)
- **Actions**: CamelCase (e.g., `AddAuditEntry`, `UpdatePolicy`)
- **Properties**: P-NO-* prefix (e.g., P-NO-BACKDATE)
- **Temporal Operators**: 
  - `◻` (Always/Invariant)
  - `◇` (Eventually)
  - `⊢` (Entails/Implies)
  - `∀` (For all)
  - `∃` (Exists)

---

## 1. P-NO-BACKDATE: Audit Log Temporal Integrity

### Property Definition

**Formal Statement**:
```
◻ ∀ e₁, e₂ ∈ AuditLog: 
  (e₁.index < e₂.index) ⊢ (e₁.timestamp ≤ e₂.timestamp)
```

**Informal Description**: Audit log entries must have monotonically non-decreasing timestamps. No entry can be inserted with a timestamp earlier than any previously recorded entry.

### State Model

```
AuditLog = Sequence of AuditEntry
AuditEntry = {
  index: Natural,
  timestamp: Timestamp,
  event_type: String,
  payload: JSON,
  merkle_hash: Hash,
  prev_hash: Hash
}
```

### Forbidden Transitions

#### FT1: Backdated Insertion
```
FORBIDDEN:
  AddAuditEntry(entry) WHERE
    entry.timestamp < MAX(AuditLog[i].timestamp for i < entry.index)
```

#### FT2: Timestamp Rollback
```
FORBIDDEN:
  ModifyAuditEntry(index, new_timestamp) WHERE
    new_timestamp < AuditLog[index].timestamp
```

#### FT3: Out-of-Order Batch Insert
```
FORBIDDEN:
  BatchAddAuditEntries([e₁, e₂, ..., eₙ]) WHERE
    ∃ i, j: i < j AND eᵢ.timestamp > eⱼ.timestamp
```

### Enforcement Mechanisms

1. **Server-Side Timestamp Generation**: All timestamps generated by trusted server clock
2. **Monotonic Clock**: Use system monotonic clock (no NTP-based rollback)
3. **Merkle Chain**: Each entry cryptographically links to previous entry's hash
4. **Immutable Log**: Append-only data structure with write-once semantics

### Verification Strategy

```python
def verify_no_backdate(audit_log: List[AuditEntry]) -> bool:
    """Verify P-NO-BACKDATE property"""
    for i in range(1, len(audit_log)):
        if audit_log[i].timestamp < audit_log[i-1].timestamp:
            return False  # Violation detected
        if audit_log[i].index != i:
            return False  # Index integrity violated
        if not verify_merkle_chain(audit_log[i], audit_log[i-1]):
            return False  # Chain broken
    return True
```

### Adversarial Attack Scenarios

| Attack | Mitigation |
|--------|------------|
| **Time Travel Attack**: Attacker manipulates system clock to insert backdated entries | Monotonic clock + external NTP sync validation |
| **Log Poisoning**: Compromised admin attempts to insert historical entries | Multi-signature requirement for audit operations |
| **Merkle Chain Forgery**: Attacker tries to rewrite history by recomputing hashes | External anchoring to blockchain/RFC 3161 timestamp authority |

### Test Cases

```python
# tests/misuse/test_no_backdate.py
def test_reject_backdated_entry():
    """Test that backdated entries are rejected"""
    log = AuditLog()
    log.add_entry(event="action1", timestamp=datetime(2025, 1, 1, 12, 0))
    log.add_entry(event="action2", timestamp=datetime(2025, 1, 1, 12, 5))
    
    with pytest.raises(AuditIntegrityError):
        log.add_entry(event="backdated", timestamp=datetime(2025, 1, 1, 11, 0))
```

---

## 2. P-NO-REPLAY: Replay Attack Prevention

### Property Definition

**Formal Statement**:
```
◻ ∀ request r: 
  (r.nonce ∈ UsedNonces) ⊢ Reject(r)
  AND
  (Age(r.timestamp) > ReplayWindow) ⊢ Reject(r)
```

**Informal Description**: Every authenticated request must include a unique nonce. Once used, a nonce cannot be reused. Requests with timestamps outside the replay window are rejected.

### State Model

```
UsedNonces = Set of (nonce_value, expiry_timestamp)
ReplayWindow = 5 minutes  # Configurable
Request = {
  nonce: UUID,
  timestamp: Timestamp,
  signature: Signature,
  payload: JSON
}
```

### Forbidden Transitions

#### FT1: Nonce Reuse
```
FORBIDDEN:
  ProcessRequest(req) WHERE
    req.nonce ∈ UsedNonces.keys()
```

#### FT2: Expired Timestamp
```
FORBIDDEN:
  ProcessRequest(req) WHERE
    |CurrentTime() - req.timestamp| > ReplayWindow
```

#### FT3: Nonce Cache Bypass
```
FORBIDDEN:
  ProcessRequest(req) WHERE
    NOT CheckNonceCache(req.nonce) AND ProcessPayload(req.payload)
```

### Enforcement Mechanisms

1. **Distributed Nonce Cache**: Redis/Memcached with TTL = ReplayWindow
2. **Cryptographic Nonces**: UUIDv4 or cryptographically random 256-bit values
3. **Timestamp Validation**: Server clock with ±30 second tolerance for clock skew
4. **Sliding Window**: Nonces expire after ReplayWindow, allowing garbage collection

### Verification Strategy

```python
def verify_no_replay(request: Request, nonce_cache: NonceCache) -> bool:
    """Verify P-NO-REPLAY property"""
    # Check nonce uniqueness
    if nonce_cache.exists(request.nonce):
        return False  # Replay attack detected
    
    # Check timestamp freshness
    time_diff = abs(datetime.utcnow() - request.timestamp)
    if time_diff > timedelta(minutes=5):
        return False  # Request too old or from future
    
    # Store nonce with TTL
    nonce_cache.add(request.nonce, ttl=300)
    return True
```

### Adversarial Attack Scenarios

| Attack | Mitigation |
|--------|------------|
| **Replay Attack**: Attacker captures and replays valid signed request | Nonce cache prevents reuse |
| **Distributed Replay**: Attacker targets multiple servers with same request | Shared Redis cache across all nodes |
| **Nonce Flooding**: Attacker floods cache with nonces to exhaust memory | Rate limiting + cache eviction policy |
| **Clock Skew Exploitation**: Attacker uses clock skew to extend replay window | NTP sync + strict ±30s tolerance |

### Test Cases

```python
# tests/misuse/test_no_replay.py
def test_reject_replay_attack():
    """Test that replayed requests are rejected"""
    cache = NonceCache()
    req = Request(nonce="unique-123", timestamp=datetime.utcnow())
    
    assert process_request(req, cache) == True  # First request succeeds
    assert process_request(req, cache) == False  # Replay rejected
```

---

## 3. P-NO-PRIV-ESC: Privilege Escalation Prevention

### Property Definition

**Formal Statement**:
```
◻ ∀ agent a, permission p:
  (p ∉ a.assigned_permissions) ⊢ ¬CanExecute(a, p)
  AND
  ∀ action AssignPermission(a, p):
    RequireMultiSig(action) ∧ AuditLog(action)
```

**Informal Description**: Agents can only execute actions for which they have explicitly assigned permissions. Permission assignments require multi-signature approval and are fully audited.

### State Model

```
Agent = {
  id: AgentID,
  role: Role,
  assigned_permissions: Set[Permission],
  trust_level: TrustLevel  # From zero-trust architecture
}

Permission = {
  resource: ResourceType,
  action: ActionType,
  scope: Scope
}

RBAC = {
  roles: Map[RoleID, Set[Permission]],
  role_hierarchy: DirectedAcyclicGraph,
  permission_grants: Map[AgentID, Set[Permission]]
}
```

### Forbidden Transitions

#### FT1: Unauthorized Action Execution
```
FORBIDDEN:
  ExecuteAction(agent, action, resource) WHERE
    NOT HasPermission(agent, action, resource)
```

#### FT2: Self-Permission Grant
```
FORBIDDEN:
  GrantPermission(granting_agent, target_agent, permission) WHERE
    granting_agent.id == target_agent.id
```

#### FT3: Role Escalation via Hierarchy Bypass
```
FORBIDDEN:
  AssignRole(agent, role) WHERE
    role NOT IN AllowedRoles(agent.current_role, RBAC.role_hierarchy)
```

#### FT4: Privilege Inheritance Violation
```
FORBIDDEN:
  ExecuteAction(agent, action, resource) WHERE
    action.required_trust_level > agent.trust_level
```

### Enforcement Mechanisms

1. **RBAC with Least Privilege**: Default deny, explicit grant model
2. **Multi-Signature Approval**: k-of-n signatures required for privilege changes
3. **Separation of Duties**: Different agents required for request and approval
4. **Continuous Authentication**: Trust level reevaluation per Zero Trust Architecture
5. **Audit Trail**: All permission checks and grants logged to immutable audit log

### Verification Strategy

```python
def verify_no_priv_esc(agent: Agent, action: Action, rbac: RBAC) -> bool:
    """Verify P-NO-PRIV-ESC property"""
    # Check direct permissions
    if action.permission in agent.assigned_permissions:
        return True
    
    # Check role-based permissions
    role_permissions = rbac.roles.get(agent.role, set())
    if action.permission in role_permissions:
        return True
    
    # Check trust level
    if action.required_trust_level > agent.trust_level:
        return False
    
    # No privilege found
    return False
```

### Adversarial Attack Scenarios

| Attack | Mitigation |
|--------|------------|
| **Vertical Privilege Escalation**: Low-privilege agent attempts admin action | RBAC enforcement at API gateway |
| **Horizontal Privilege Escalation**: Agent accesses another agent's resources | Tenant isolation + resource ownership checks |
| **Role Hierarchy Attack**: Exploit inheritance to gain unintended permissions | DAG validation prevents cycles, explicit inheritance rules |
| **Token Theft/Replay**: Stolen auth token used for privileged actions | Short-lived tokens + nonce-based replay prevention |
| **Confused Deputy**: Trick high-privilege agent to perform action on behalf of attacker | Explicit origin tracking + intent verification |

### Test Cases

```python
# tests/misuse/test_no_priv_esc.py
def test_reject_unauthorized_action():
    """Test that unauthorized actions are blocked"""
    low_priv_agent = Agent(role="viewer", permissions={"read"})
    
    with pytest.raises(AuthorizationError):
        execute_action(low_priv_agent, action="delete_policy")
```

---

## 4. P-NO-DATA-LEAK: Cross-Tenant Data Leakage Prevention

### Property Definition

**Formal Statement**:
```
◻ ∀ tenant₁, tenant₂, data d:
  (d ∈ tenant₁.data) ⊢ ¬CanAccess(tenant₂.agents, d)
  AND
  ∀ query q:
    (q.tenant_id = tenant₁.id) ⊢ Results(q) ⊆ tenant₁.data
```

**Informal Description**: Data belonging to one tenant must never be accessible to agents of another tenant. All queries are scoped to the requesting tenant's data partition.

### State Model

```
Tenant = {
  id: TenantID,
  data: Set[DataObject],
  network_segment: VirtualNetwork,
  encryption_key: Key
}

DataObject = {
  id: ObjectID,
  tenant_id: TenantID,
  content: EncryptedBlob,
  access_control_list: ACL
}

TenantIsolation = {
  network_isolation: Map[TenantID, NetworkSegment],
  data_encryption: Map[TenantID, EncryptionKey],
  database_schemas: Map[TenantID, SchemaName]
}
```

### Forbidden Transitions

#### FT1: Cross-Tenant Data Access
```
FORBIDDEN:
  AccessData(agent, data_object) WHERE
    agent.tenant_id ≠ data_object.tenant_id
```

#### FT2: Aggregation Leakage
```
FORBIDDEN:
  ExecuteQuery(query) WHERE
    query.result CONTAINS data FROM (tenant_id ≠ query.tenant_id)
```

#### FT3: Cache Poisoning
```
FORBIDDEN:
  CacheResult(key, value) WHERE
    key.tenant_id ≠ value.source_tenant_id
```

#### FT4: Inference Attack via Metadata
```
FORBIDDEN:
  ExposeMetadata(metadata) WHERE
    metadata REVEALS_INFO_ABOUT(other_tenant.data)
```

### Enforcement Mechanisms

1. **Network Segmentation**: Separate VLANs/VPCs per tenant (Phase 4 implementation)
2. **Database-Level Isolation**: Separate schemas or databases per tenant
3. **Encryption at Rest**: Tenant-specific encryption keys (KEK per tenant)
4. **Row-Level Security**: Database RLS policies enforce tenant_id filtering
5. **Query Rewriting**: Automatic injection of tenant_id predicates
6. **Audit Logging**: All cross-tenant access attempts logged and alerted

### Verification Strategy

```python
def verify_no_data_leak(query: Query, results: List[DataObject]) -> bool:
    """Verify P-NO-DATA-LEAK property"""
    query_tenant = query.tenant_id
    
    for result in results:
        if result.tenant_id != query_tenant:
            return False  # Data leakage detected
    
    # Verify no inference via aggregates
    if query.is_aggregate:
        if not verify_differential_privacy(query, results):
            return False  # Statistical leakage detected
    
    return True
```

### Adversarial Attack Scenarios

| Attack | Mitigation |
|--------|------------|
| **SQL Injection to Bypass Filters**: Inject SQL to remove tenant_id predicate | Parameterized queries + ORM with automatic tenant filtering |
| **Timing Attack**: Infer existence of cross-tenant data via query timing | Constant-time responses + noise injection |
| **Cache Collision**: Exploit cache key collision to access other tenant's data | Include tenant_id in all cache keys + namespacing |
| **Shared Resource Contention**: Infer cross-tenant data via resource usage patterns | Resource quotas + noisy resource metrics |
| **API Parameter Tampering**: Modify tenant_id in API requests | Server-side session management + JWT validation |

### Test Cases

```python
# tests/misuse/test_no_data_leak.py
def test_reject_cross_tenant_access():
    """Test that cross-tenant data access is blocked"""
    tenant1_agent = Agent(tenant_id="tenant-1")
    tenant2_data = DataObject(tenant_id="tenant-2", content="secret")
    
    with pytest.raises(TenantIsolationError):
        access_data(tenant1_agent, tenant2_data)
```

---

## 5. P-NO-TAMPER: Policy Tampering Detection

### Property Definition

**Formal Statement**:
```
◻ ∀ policy p ∈ PolicyStore:
  Verify(p.hash, p.content) ∧ Verify(p.signatures, p.content)
  AND
  ∀ action UpdatePolicy(p):
    RequireMultiSig(action) ∧ 
    CreateLineageEntry(p.prev_hash, p.new_hash) ∧
    AuditLog(action)
```

**Informal Description**: All policies are cryptographically hashed and signed. Any modification creates a new version with lineage tracking. Tampering is detectable via hash verification.

### State Model

```
Policy = {
  id: PolicyID,
  version: Version,
  content: PolicyCode,
  hash: SHA256Hash,
  signatures: Set[Signature],
  prev_hash: SHA256Hash,
  approvers: Set[AgentID]
}

PolicyLineage = {
  chains: Map[PolicyID, List[PolicyVersion]],
  merkle_roots: List[MerkleRoot],
  external_anchors: List[AnchorReference]
}
```

### Forbidden Transitions

#### FT1: In-Place Modification
```
FORBIDDEN:
  ModifyPolicy(policy, new_content) WHERE
    NOT CreateNewVersion(policy)
```

#### FT2: Unsigned Policy Activation
```
FORBIDDEN:
  ActivatePolicy(policy) WHERE
    Length(policy.signatures) < RequiredSignatures
```

#### FT3: Hash Mismatch
```
FORBIDDEN:
  LoadPolicy(policy) WHERE
    ComputeHash(policy.content) ≠ policy.hash
```

#### FT4: Signature Forgery
```
FORBIDDEN:
  AcceptPolicy(policy) WHERE
    ∃ sig ∈ policy.signatures: NOT VerifySignature(sig, policy.hash)
```

#### FT5: Lineage Break
```
FORBIDDEN:
  CreatePolicyVersion(p_new) WHERE
    p_new.prev_hash ≠ Hash(p_old.content)
```

### Enforcement Mechanisms

1. **Content-Addressable Storage**: Policies stored by hash (immutable)
2. **Multi-Signature Scheme**: k-of-n signatures required (Phase 4 implementation)
3. **Merkle Tree Lineage**: Hash chain with periodic Merkle root anchoring
4. **External Timestamping**: RFC 3161 timestamp authority or blockchain anchoring
5. **Copy-on-Write**: All modifications create new versions, old versions retained
6. **Periodic Verification**: Background job validates all policy hashes and signatures

### Verification Strategy

```python
def verify_no_tamper(policy: Policy, policy_store: PolicyStore) -> bool:
    """Verify P-NO-TAMPER property"""
    # Verify content hash
    computed_hash = hashlib.sha256(policy.content.encode()).hexdigest()
    if computed_hash != policy.hash:
        return False  # Tampering detected
    
    # Verify all signatures
    for sig in policy.signatures:
        if not verify_signature(sig, policy.hash, sig.public_key):
            return False  # Invalid signature
    
    # Verify lineage chain
    if policy.version > 1:
        prev_policy = policy_store.get_version(policy.id, policy.version - 1)
        if policy.prev_hash != prev_policy.hash:
            return False  # Lineage broken
    
    return True
```

### Adversarial Attack Scenarios

| Attack | Mitigation |
|--------|------------|
| **Policy Injection**: Attacker injects malicious policy | Multi-sig prevents unauthorized activation |
| **Hash Collision**: Attacker finds SHA-256 collision to substitute policy | Cryptographically secure hash (SHA-256 collision resistance ~2^128 operations) |
| **Signature Stripping**: Remove signatures before verification | Verification mandatory, unsigned policies rejected |
| **Rollback Attack**: Revert to old vulnerable policy version | Lineage tracking + monotonic version numbers |
| **Merkle Tree Forgery**: Rewrite policy history | External anchoring to blockchain/timestamp authority |

### Test Cases

```python
# tests/misuse/test_no_tamper.py
def test_detect_policy_tampering():
    """Test that tampered policies are detected"""
    policy = Policy(content="allow all", hash="abc123")
    
    # Tamper with content
    policy.content = "deny all"
    
    assert verify_policy(policy) == False  # Tampering detected
```

---

## 6. P-NO-DOS: Denial of Service Prevention

### Property Definition

**Formal Statement**:
```
◻ ∀ agent a, resource r:
  ResourceUsage(a, r) ≤ Quota(a, r)
  AND
  ∀ request req:
    RateLimit(req.source) ⊢ ThrottleOrDrop(req)
  AND
  AvailabilityMetric() ≥ 0.99  # 99% uptime SLO
```

**Informal Description**: The system enforces resource quotas and rate limits to prevent any single agent or tenant from exhausting shared resources. The system maintains 99% availability even under attack.

### State Model

```
ResourceQuota = {
  cpu_seconds_per_minute: Float,
  memory_mb: Integer,
  requests_per_minute: Integer,
  policy_evaluations_per_hour: Integer
}

RateLimiter = {
  token_bucket: TokenBucket,
  sliding_window: SlidingWindowCounter,
  circuit_breaker: CircuitBreaker
}

AvailabilityMetrics = {
  uptime_percentage: Float,
  error_rate: Float,
  p95_latency_ms: Float
}
```

### Forbidden Transitions

#### FT1: Quota Exhaustion
```
FORBIDDEN:
  AllocateResource(agent, resource, amount) WHERE
    CurrentUsage(agent, resource) + amount > Quota(agent, resource)
```

#### FT2: Rate Limit Bypass
```
FORBIDDEN:
  ProcessRequest(req) WHERE
    RequestsInWindow(req.source) ≥ RateLimit(req.source)
```

#### FT3: Unbounded Policy Evaluation
```
FORBIDDEN:
  EvaluatePolicy(policy, context) WHERE
    EstimatedComplexity(policy) > MaxComplexity
    OR EstimatedTime(policy) > TimeoutThreshold
```

#### FT4: Resource Leak
```
FORBIDDEN:
  AllocateResource(r) WITHOUT EnsureRelease(r, timeout)
```

### Enforcement Mechanisms

1. **Token Bucket Rate Limiting**: Per-agent and per-tenant limits
2. **Resource Quotas**: CPU, memory, request limits per tenant
3. **Circuit Breaker**: Automatic failover on overload detection
4. **Request Timeouts**: Hard timeout on policy evaluations (e.g., 5 seconds)
5. **Priority Queues**: High-priority requests processed first during overload
6. **Load Shedding**: Graceful degradation by dropping low-priority requests
7. **Chaos Engineering**: Periodic resilience testing (Phase 8 stress tests)

### Verification Strategy

```python
def verify_no_dos(system_metrics: SystemMetrics, quotas: QuotaConfig) -> bool:
    """Verify P-NO-DOS property"""
    # Check resource usage within quotas
    for tenant in system_metrics.tenants:
        if tenant.cpu_usage > quotas.cpu_limit:
            return False  # Quota violation
        if tenant.request_rate > quotas.rate_limit:
            return False  # Rate limit violation
    
    # Check availability SLO
    if system_metrics.uptime < 0.99:
        return False  # Availability SLO violated
    
    # Check latency SLO
    if system_metrics.p95_latency > quotas.max_latency_ms:
        return False  # Latency SLO violated
    
    return True
```

### Adversarial Attack Scenarios

| Attack | Mitigation |
|--------|------------|
| **Request Flood**: Overwhelm system with high request volume | Rate limiting + DDoS protection (Cloudflare/AWS Shield) |
| **Slowloris Attack**: Slow requests exhaust connection pool | Connection timeouts + max concurrent connections |
| **CPU Exhaustion**: Complex policy evaluations consume all CPU | Policy complexity limits + evaluation timeouts |
| **Memory Bomb**: Large payloads exhaust memory | Request size limits + memory quotas |
| **Amplification Attack**: Small request triggers large computation | Complexity analysis + amplification factor limits |
| **Distributed DoS**: Attack from multiple sources | Distributed rate limiting + IP reputation |

### Test Cases

```python
# tests/misuse/test_no_dos.py
def test_enforce_rate_limit():
    """Test that rate limits are enforced"""
    agent = Agent(quota={"requests_per_minute": 100})
    
    # Make 100 requests (within limit)
    for i in range(100):
        assert process_request(agent) == True
    
    # 101st request should be throttled
    assert process_request(agent) == False  # Rate limit enforced
```

---

## Negative State Transition Specifications

### Forbidden State Transitions Matrix

| From State | Forbidden Transition | To State | Property Violated |
|------------|---------------------|----------|-------------------|
| AuditLog[n] | Insert entry with timestamp < AuditLog[n].timestamp | AuditLog[n+1] | P-NO-BACKDATE |
| Request Processed | Reprocess request with same nonce | Request Completed | P-NO-REPLAY |
| Agent with Role=Viewer | Execute action requiring Admin role | Privileged Action Completed | P-NO-PRIV-ESC |
| Tenant1 Context | Access Tenant2 data | Data Returned | P-NO-DATA-LEAK |
| Policy[v1] Active | Modify content without creating v2 | Policy[v1] Modified | P-NO-TAMPER |
| Normal Load | Accept unlimited requests | System Overload | P-NO-DOS |

### State Space Exploration

For model checking, we define the complete state space:

```tla+
---- MODULE NegativeProperties ----
EXTENDS TLC, Integers, Sequences

VARIABLES auditLog, usedNonces, policies, tenantData, systemLoad

\* P-NO-BACKDATE
NoBackdating == 
  \A i \in 1..Len(auditLog)-1 :
    auditLog[i].timestamp <= auditLog[i+1].timestamp

\* P-NO-REPLAY  
NoReplay ==
  \A req \in ProcessedRequests :
    req.nonce \notin usedNonces => 
      ProcessRequest(req) /\ usedNonces' = usedNonces \cup {req.nonce}

\* P-NO-PRIV-ESC
NoPrivilegeEscalation ==
  \A agent, action :
    Execute(agent, action) => HasPermission(agent, action)

\* P-NO-DATA-LEAK
NoDataLeakage ==
  \A tenant1, tenant2, data :
    data \in tenantData[tenant1] => 
      \A agent \in tenant2.agents : ~CanAccess(agent, data)

\* P-NO-TAMPER
NoPolicyTampering ==
  \A policy \in policies :
    Hash(policy.content) = policy.hash /\
    VerifySignatures(policy.signatures, policy.hash)

\* P-NO-DOS
NoDenialOfService ==
  systemLoad.cpu_usage < QUOTA_CPU /\
  systemLoad.request_rate < QUOTA_RATE /\
  systemLoad.availability >= 0.99

\* Combined Safety Property
NegativeInvariants ==
  NoBackdating /\ NoReplay /\ NoPrivilegeEscalation /\
  NoDataLeakage /\ NoPolicyTampering /\ NoDenialOfService

====
```

---

## Verification and Testing Strategy

### 1. Formal Verification (TLA+ Model Checking)

- **Tool**: TLC model checker
- **Approach**: Exhaustive state space exploration for small models
- **Coverage**: All 6 negative properties verified in finite state models

### 2. Property-Based Testing (Hypothesis)

```python
from hypothesis import given, strategies as st

@given(st.lists(st.datetimes()))
def test_no_backdate_property(timestamps):
    """Property-based test for P-NO-BACKDATE"""
    audit_log = AuditLog()
    sorted_timestamps = sorted(timestamps)
    
    for ts in sorted_timestamps:
        audit_log.add_entry(event="test", timestamp=ts)
    
    assert verify_no_backdate(audit_log)
```

### 3. Adversarial Testing (Misuse Test Suite)

- **Location**: `tests/misuse/`
- **Coverage**: 100+ test cases per property
- **Approach**: Actively attempt to violate each negative property

### 4. Fuzzing

```python
# tests/misuse/fuzz_policy_engine.py
import atheris

def fuzz_policy_evaluation(data):
    """Fuzz policy engine to find DoS vulnerabilities"""
    try:
        policy = parse_policy(data)
        evaluate_policy(policy, context={})
    except Exception:
        pass  # Expected for invalid inputs

atheris.Setup(sys.argv, fuzz_policy_evaluation)
atheris.Fuzz()
```

### 5. Chaos Engineering

- **Tool**: Chaos Monkey, Chaos Mesh
- **Scenarios**: Random pod termination, network partitions, resource exhaustion
- **Goal**: Verify negative properties hold under Byzantine faults

---

## Monitoring and Alerting

### Runtime Monitors

Each negative property has a corresponding runtime monitor:

```python
class NegativePropertyMonitor:
    def monitor_no_backdate(self, audit_log: AuditLog):
        """Real-time monitoring of P-NO-BACKDATE"""
        if not verify_no_backdate(audit_log):
            self.alert("P-NO-BACKDATE violation detected", severity="CRITICAL")
    
    def monitor_no_replay(self, request: Request, cache: NonceCache):
        """Real-time monitoring of P-NO-REPLAY"""
        if cache.exists(request.nonce):
            self.alert("P-NO-REPLAY violation: replay attack detected", 
                      severity="HIGH", source=request.source)
    
    # Similar monitors for other properties...
```

### Alert Thresholds

| Property | Alert Condition | Severity | MTTD Target |
|----------|----------------|----------|-------------|
| P-NO-BACKDATE | Any violation | CRITICAL | <1 minute |
| P-NO-REPLAY | Replay attempt | HIGH | <2 minutes |
| P-NO-PRIV-ESC | Unauthorized action attempt | CRITICAL | <1 minute |
| P-NO-DATA-LEAK | Cross-tenant access attempt | CRITICAL | <1 minute |
| P-NO-TAMPER | Hash mismatch | CRITICAL | <30 seconds |
| P-NO-DOS | Request rate >90% of limit | MEDIUM | <5 minutes |

---

## Success Criteria

### Formal Verification
- ✅ All 6 negative properties formally specified in TLA+
- ✅ Model checking completed with no counterexamples found
- ✅ Proofs cover finite state models (≤10^6 states per property)

### Testing
- ✅ 100+ adversarial test cases per property
- ✅ All test cases pass with 0 false negatives
- ✅ Fuzzing runs for 24 hours with 0 critical issues
- ✅ Property-based tests with 10,000 examples per property

### Operational
- ✅ Runtime monitors deployed for all properties
- ✅ Mean time to detect (MTTD) < 5 minutes for all violations
- ✅ Zero successful attacks in red team exercises
- ✅ 99% system availability maintained under adversarial load

---

## References

1. **Phase 3**: Formal Core Modeling (positive invariants P-DET, P-TERM, P-ACYCLIC, P-AUD)
2. **Phase 4**: Access Control & Multi-Sig (P-AUTH, P-MULTI-SIG)
3. **Phase 5**: Threat Modeling (STRIDE analysis)
4. **Phase 6**: AI/ML Security (adversarial defenses)
5. **Phase 7**: Runtime Probes (operational monitoring)
6. **OWASP Top 10**: Common web application vulnerabilities
7. **MITRE ATT&CK**: Adversarial tactics, techniques, and procedures
8. **NIST SP 800-53**: Security and privacy controls
9. **RFC 3161**: Time-Stamp Protocol (TSP)
10. **TLA+ Specification**: Formal temporal logic specification language

---

## Revision History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | 2025-11-17 | Nethical Team | Initial negative properties specification |

---

**Status**: DRAFT
**Next Review**: After Phase 8 red team exercises
**Approval**: Pending multi-signature approval (3-of-5 required)
